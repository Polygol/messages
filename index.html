<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Messages</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,700,1,0" />
    <script src="/assets/gurapp/api/gurasuraisu-api.js" defer></script>
    <script type="module">
        import { joinRoom, selfId } from 'https://esm.sh/trystero@0.15.1/torrent';
        window.Trystero = { joinRoom, selfId };
        window.dispatchEvent(new Event('trystero-ready'));
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        .material-symbols-rounded {
            vertical-align: middle;
        }
        
        body {
           background-color: var(--background-color-tr);
           min-height: 100vh;
           display: flex;
           flex-direction: column;
           align-items: center;
           padding: 20px;
           padding-top: 80px;
           user-select: none;
           transition: background-color 0.3s, color 0.3s;
           color: var(--text-color);
        }
        
        .container {
           width: 100%;
           max-width: 800px;
           height: 100%;
           display: flex;
           flex-direction: column;
        }
        
        .tab-content {
            display: none;
            flex-grow: 1;
            margin-bottom: 90px;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        /* --- Input Section --- */
        .input-section {
            display: flex;
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 500px;
            width: 90%;
            z-index: 10;
        }
        
        .chat-input {
            flex-grow: 1;
            background-color: transparent;
            border: none;
            color: var(--text-color);
            font-size: 1rem;
            outline: none;
            padding: 15px 20px;
            background-color: var(--search-background);
            border-radius: 32px;
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow), 0 0 15px rgba(0, 0, 0, 0.05);
            margin-right: 15px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        
        .add-btn {
            padding: 15px 15px;
            background-color: var(--search-background);
            border-radius: 32px;
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow), 0 0 15px rgba(0, 0, 0, 0.05);
            color: var(--text-color);
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            cursor: pointer;
        }

        .chat-input:focus {
            margin-right: 0;
            min-width: 100%;
        }

        .input-section:has(.chat-input:focus) .add-btn {
            scale: 0;
            width: 0;
            opacity: 0;
            padding: 0;
            border: 0;
            margin: 0;
        }
        
        /* --- Chat Messages --- */
        .chat-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            flex-grow: 1;
            scroll-behavior: smooth;
        }

        .chat-container::-webkit-scrollbar {
            display: none;
        }

        .message-bubble {
            position: relative;
            display: flex;
            flex-direction: column;
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 35px;
            box-shadow: var(--sun-shadow);
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            animation: popIn 0.3s cubic-bezier(0.2, 1.3, 0.64, 1);
            corner-shape: superellipse(1.5);
            scroll-margin-bottom: 120px;
        }

        .message-bubble.mine {
            align-self: flex-end;
            background-color: var(--accent);
            color: var(--background-color);
            border-bottom-right-radius: 20px;
        }

        .message-bubble.theirs {
            align-self: flex-start;
            background-color: var(--search-background);
            border-bottom-left-radius: 20px;
        }
        
        .message-image {
            max-width: 100%;
            border-radius: 12px;
            corner-shape: superellipse(1.5);
            border: 1px solid var(--glass-border);
        }

        .reply-banner {
            font-size: 0.75rem;
            opacity: 0.7;
            border-left: 2px solid var(--text-color);
            padding-left: 6px;
            margin-bottom: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .reactions-container {
            position: absolute;
            bottom: -10px;
            right: 10px;
            display: flex;
            gap: 4px;
            background: var(--accent);
            color: var(--background-color);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 0.8rem;
            backdrop-filter: var(--edge-refraction-filter);
            box-shadow: var(--sun-shadow);
            z-index: 5;
        }

        /* Poll Styling */
        .poll-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
            min-width: 200px;
        }
        .poll-option {
            position: relative;
            background: var(--search-background);
            box-shadow: var(--sun-shadow);
            border: 1px solid var(--glass-border);
            padding: 8px 14px;
            border-radius: 50px;
            cursor: pointer;
            overflow: hidden;
            font-size: 0.9rem;
        }
        .poll-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: var(--tonal);
            opacity: 0.5;
            transition: width 0.5s cubic-bezier(0.2, 1, 0.3, 1);
        }
        .poll-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-top: 4px;
            opacity: 0.7;
        }

        #replying-to-indicator {
            position: absolute;
            top: -45px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--search-background);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            display: none;
            align-items: center;
            gap: 10px;
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--edge-refraction-filter);
            box-shadow: var(--sun-shadow);
            white-space: nowrap;
            max-width: 90%;
            z-index: 5;
        }

        .typing-indicator-pill {
            position: fixed;
            bottom: 95px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            backdrop-filter: var(--edge-refraction-filter);
            box-shadow: var(--sun-shadow);
            z-index: 9;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .typing-indicator-pill.visible {
            opacity: 1;
        }

        .sender-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .sender-pfp {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
        }

        .message-sender {
            font-size: 0.8rem;
            word-wrap: break-word;
            color: var(--secondary-text-color);
            font-weight: 500;
        }

        .message-text {
            font-size: 1rem;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .message-time {
            font-size: 0.65rem;
            align-self: flex-end;
            margin-top: 4px;
            opacity: 0.6;
        }

        /* --- Chats List --- */
        .chat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background-color: var(--search-background);
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            margin-bottom: 8px;
            gap: 14px;
            transition: all 0.3s cubic-bezier(.2, 1.3, .64, 1);
        }
        
        .chat-item:active {
            transform: scale(1.1);
            filter: brightness(1.5);
            transition: all 0.3s cubic-bezier(.2, 1.3, .64, 1);
        }

        .chat-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--accent);
            color: var(--background-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
        }

        /* --- Room Settings --- */
        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background-color: var(--search-background);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-size: 0.9rem;
            color: var(--secondary-text-color);
            font-weight: 500;
        }

        .form-input {
            padding: 12px 16px;
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            border: 1px solid var(--glass-border);
            background-color: var(--search-background);
            box-shadow: var(--sun-shadow);
            color: var(--text-color);
            font-size: 1rem;
            outline: none;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            background-color: var(--transparent-color);
            align-self: flex-start;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff5252;
            transition: background-color 0.3s;
        }

        .status-dot.connected {
            background-color: #4caf50;
        }

        .peer-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 15px;
        }

        .peer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background-color: var(--search-background);
            border-radius: 20px;
            corner-shape: superellipse(1.5);
            border: 1px solid var(--glass-border);
            box-shadow: var(--sun-shadow);
        }

        /* Settings UI */
        .profile-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: var(--search-background);
            border-radius: 50px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--sun-shadow);
            corner-shape: superellipse(1.5);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
        }

        /* Animations */
        @keyframes popIn {
            from { opacity: 0; transform: scale(0.9) translateY(10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
    </style>
</head>
<body data-app-name="MESSAGES">
    <div class="container">
    <!-- Setup Screen (Overlay) -->
    <div id="setup-screen" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:var(--background-color-tr); backdrop-filter: blur(50px); z-index:9999; flex-direction:column; align-items:center; justify-content:center; padding:20px;">
        <h2 style="margin-bottom:20px;">Polygol Messages</h2>
        <div id="pfp-preview" style="width:120px; height:120px; border-radius:50%; background:var(--search-background); margin-bottom:20px; background-size:cover; background-position:center; display:flex; align-items:center; justify-content:center; cursor:pointer;" onclick="document.getElementById('upload-pfp-btn').click()">
            <span class="material-symbols-rounded" style="font-size:40px; opacity:0.5;">add_a_photo</span>
        </div>
        <button id="upload-pfp-btn" class="add-btn" style="margin-bottom:20px; display: none;">Add a picture</button>
        <input type="text" id="setup-name" class="form-input" placeholder="Name" style="width:100%; max-width:300px; margin-bottom:20px;">
        <button id="finish-setup-btn" class="add-btn" style="width:100%; max-width:300px; background:var(--accent); color:var(--background-color);">Get Started</button>
    </div>

    <div class="container">
        <!-- Toolbar -->
        <div class="toolbar">
            <button class="tab-btn active" data-tab="chats"><span class="material-symbols-rounded">home</span>Home</button>
            <button class="tab-btn" data-tab="chat" id="tab-btn-chat" style="display:none;"><span class="material-symbols-rounded">chat</span>Chat</button>
            <button class="tab-btn" data-tab="profile"><span class="material-symbols-rounded">account_circle</span>You</button>
        </div>
        
        <!-- Chats List Tab -->
        <div class="tab-content active" id="chats-content">
            <div id="chat-list-container" class="peer-list">
                <div style="font-size: 0.85rem; padding: 10px;">Start a conversation</div>
            </div>
            <div class="input-section">
                <input type="text" class="chat-input" id="join-code-input" placeholder="Enter code or chat name" autocomplete="off">
                <button class="add-btn" id="join-create-chat-btn"><span class="material-symbols-rounded">add</span></button>
            </div>
        </div>

        <!-- Chat View Tab -->
        <div class="tab-content" id="chat-content">
            <div class="chat-header" id="chat-header" style="padding: 10px 20px; display:flex; align-items:center; gap:10px; border-bottom:1px solid var(--glass-border); margin-bottom:10px; justify-content: space-between;">
                <div style="display:flex; align-items:center; gap:10px;">
                    <h3 id="current-chat-title" style="margin:0; font-family:'Open Runde', sans-serif;">Select a chat</h3>
                </div>
                <div class="status-badge" id="connection-status">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text" style="font-size: 10px;">Code: -</span>
                </div>
            </div>
            
            <div class="chat-container" id="chat-messages">
                <div style="text-align: center; opacity: 0.5; font-size: 0.85rem; margin-top: 20px;" id="empty-state">
                    Start a conversation
                </div>
            </div>
            
            <div class="input-section">
                <div id="typing-indicator" class="typing-indicator-pill">Typing...</div>
                <div id="replying-to-indicator">
                    <span id="replying-to-text" style="overflow:hidden; text-overflow:ellipsis;">Replying</span>
                    <span class="material-symbols-rounded" style="font-size: 14px; cursor:pointer;" onclick="cancelReply()">close</span>
                </div>
                <input type="text" class="chat-input" id="message-input" placeholder="Type a message" autocomplete="off">
                <button class="add-btn" id="poll-btn" style="margin-right: 15px;"><span class="material-symbols-rounded">thumbs_up_double</span></button>
                <button class="add-btn" id="attach-btn" style="margin-right: 15px;"><span class="material-symbols-rounded">filter_vintage</span></button>
                <button class="add-btn" id="send-btn"><span class="material-symbols-rounded">arrow_upward</span></button>
            </div>
        </div>

        <!-- Profile/Settings Tab -->
        <div class="tab-content" id="profile-content">
            <div class="profile-card">
                <div id="settings-pfp-preview" style="width:100px; height:100px; border-radius:50%; background-size:cover; background-position:center; cursor:pointer; border: 2px solid var(--glass-border);"></div>
                <input type="text" id="settings-name-input" class="form-input" style="width:100%; text-align:center;" placeholder="Your Display Name">
                <button id="save-profile-btn" class="add-btn" style="width:100%; background:var(--accent); color:var(--background-color);">Save</button>
                <div style="font-size: 0.7rem; opacity: 0.5; margin-top: 10px;">Your unique ID: <span id="my-internal-id">...</span></div>
            </div>
        </div>
    </div>

    <script>
        // --- Tab Management ---
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (button.id === 'tab-btn-chat' && !currentChatId) return;
                
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                tabContents.forEach(content => content.classList.remove('active'));
                const tabId = button.dataset.tab + '-content';
                document.getElementById(tabId).classList.add('active');

                if (button.dataset.tab === 'chat') {
                    scrollToBottom();
                }
            });
        });

        // --- IndexedDB Setup ---
        const DB_NAME = 'socialMessagingDB';
        const DB_VERSION = 1;
        let idb;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('state')) db.createObjectStore('state');
                    if (!db.objectStoreNames.contains('messages')) db.createObjectStore('messages');
                };
                request.onsuccess = (e) => {
                    idb = e.target.result;
                    resolve();
                };
                request.onerror = (e) => reject(e.target.error);
            });
        }

        function getDB(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!idb) return resolve(null);
                const tx = idb.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        function setDB(storeName, key, value) {
            return new Promise((resolve, reject) => {
                if (!idb) return resolve();
                const tx = idb.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const req = store.put(value, key);
                req.onsuccess = () => resolve();
                req.onerror = () => reject(req.error);
            });
        }

        // --- Core State ---
        let currentUser = null;
        let chats = [];
        let profiles = {};
        let activeRooms = {};
        let currentChatId = null;

        // --- DOM Elements ---
        const setupScreen = document.getElementById('setup-screen');
        const chatListContainer = document.getElementById('chat-list-container');
        const chatMessages = document.getElementById('chat-messages');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const attachBtn = document.getElementById('attach-btn');

        // --- Initialization ---
        async function loadState() {
            // Migration from localStorage to prevent data loss for existing users
            if (localStorage.getItem('messages_user')) {
                await setDB('state', 'currentUser', JSON.parse(localStorage.getItem('messages_user')));
                localStorage.removeItem('messages_user');
            }
            if (localStorage.getItem('messages_chats')) {
                await setDB('state', 'chats', JSON.parse(localStorage.getItem('messages_chats')));
                localStorage.removeItem('messages_chats');
            }
            if (localStorage.getItem('messages_profiles')) {
                await setDB('state', 'profiles', JSON.parse(localStorage.getItem('messages_profiles')));
                localStorage.removeItem('messages_profiles');
            }

            currentUser = await getDB('state', 'currentUser') || null;
            chats = await getDB('state', 'chats') || [];
            profiles = await getDB('state', 'profiles') || {};
        }

        async function initialize() {
            await initDB();
            await loadState();

            if (!currentUser) {
                setupScreen.style.display = 'flex';
                return;
            }
            
            profiles[currentUser.id] = { name: currentUser.name, pfp: currentUser.pfp };
            await saveProfiles();

            if (!window.Trystero) {
                window.addEventListener('trystero-ready', initRooms, { once: true });
                return;
            }
            initRooms();
            updateProfileUI();
        }

        // --- Setup Logic ---
        let tempPfp = null;
        document.getElementById('upload-pfp-btn').addEventListener('click', async () => {
            try {
                const files = await Gurasuraisu.requestFile({ accept: 'image/*', multiple: false });
                if (files && files.length > 0) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        tempPfp = e.target.result;
                        document.getElementById('pfp-preview').style.backgroundImage = `url(${tempPfp})`;
                        document.getElementById('pfp-preview').innerHTML = '';
                    };
                    reader.readAsDataURL(files[0]);
                }
            } catch (err) { console.error(err); }
        });

        document.getElementById('finish-setup-btn').addEventListener('click', async () => {
            const name = document.getElementById('setup-name').value.trim();
            if (!name) return Gurasuraisu.showPopup('Enter a name');
            if (!tempPfp) return Gurasuraisu.showPopup('Choose a profile picture');

            currentUser = {
                id: 'user_' + generateRandomString(16),
                name: name,
                pfp: tempPfp
            };
            await setDB('state', 'currentUser', currentUser);
            setupScreen.style.display = 'none';
            initialize();
        });

        // --- Image Compression ---
        async function compressImage(dataUrl) {
            if (dataUrl.startsWith('data:image/gif') || dataUrl.startsWith('data:image/webp')) return dataUrl;
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    const max = 1200;
                    if (width > max || height > max) {
                        if (width > height) { height *= max / width; width = max; }
                        else { width *= max / height; height = max; }
                    }
                    canvas.width = width; canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', 0.7));
                };
                img.src = dataUrl;
            });
        }

        // --- Utility ---
        function generateRandomString(length) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
            return result;
        }

        async function saveChats() { await setDB('state', 'chats', chats); }
        async function saveProfiles() { await setDB('state', 'profiles', profiles); }

        // --- Networking ---
        function initRooms() {
            chats.forEach(chat => joinTrysteroRoom(chat.id));
            renderChatList();
        }

        function joinTrysteroRoom(chatId) {
            if (activeRooms[chatId]) return;

            const MESSAGES_CONFIG = { 
                appId: 'polygol-messages-v2',
                trackerUrls: [
                    'wss://tracker.openwebtorrent.com',
                    'wss://tracker.btorrent.xyz',
                    'wss://tracker.webtorrent.dev',
                    'wss://tracker.sloppyta.co:443/announce',
                    'wss://tracker.novage.com.ua:443/announce',
                    'wss://tracker.nanoha.org:443/announce',
                    'wss://tracker.ghostchu-services.top:443/announce',
                    'wss://tracker.files.fm:7073/announce'
                ]
            };

            try {
                const room = window.Trystero.joinRoom(MESSAGES_CONFIG, chatId);
                const [sendChat, getChat] = room.makeAction('chat');
                const [sendProfile, getProfile] = room.makeAction('profile');
                const [sendHistory, getHistory] = room.makeAction('history');
                const [sendReaction, getReaction] = room.makeAction('reaction');
                const [sendTyping, getTyping] = room.makeAction('typing');
                const [sendVote, getVote] = room.makeAction('pollVote');

                activeRooms[chatId] = { room, sendChat, sendProfile, sendHistory, sendReaction, sendTyping, sendVote };

                getChat((msg, peerId) => handleIncomingMessage(chatId, msg, peerId));
                getTyping((isTyping, peerId) => handleTyping(chatId, peerId, isTyping));
                getProfile(async (profile, peerId) => {
                    profiles[profile.id] = { name: profile.name, pfp: profile.pfp };
                    await saveProfiles();
                    if (currentChatId === chatId) renderMessages(chatId);
                });
                getHistory(async (peerHistory, peerId) => {
                    const localHistory = await getDB('messages', chatId) || [];
                    const historyMap = new Map(localHistory.map(m => [m.id, m]));
                    let changed = false;

                    peerHistory.forEach(m => {
                        if (!historyMap.has(m.id)) {
                            historyMap.set(m.id, m);
                            changed = true;
                        } else {
                            const existing = historyMap.get(m.id);
                            if (m.reactions) {
                                existing.reactions = { ...existing.reactions, ...m.reactions };
                                changed = true;
                            }
                        }
                    });

                    if (changed) {
                        const merged = Array.from(historyMap.values()).sort((a,b) => a.timestamp - b.timestamp);
                        await setDB('messages', chatId, merged);
                        if (currentChatId === chatId) renderMessages(chatId);
                    }
                });
                getReaction(async (data, peerId) => {
                    const localHistory = await getDB('messages', chatId) || [];
                    const msg = localHistory.find(m => m.id === data.messageId);
                    if (msg) {
                        if (!msg.reactions) msg.reactions = {};
                        msg.reactions[data.senderId] = data.emoji;
                        await setDB('messages', chatId, localHistory);
                        if (currentChatId === chatId) renderMessages(chatId);
                    }
                });
                getVote(async (data, peerId) => {
                    const localHistory = await getDB('messages', chatId) || [];
                    const msg = localHistory.find(m => m.id === data.msgId);
                    if (msg && msg.poll) {
                        if (!msg.poll.votes) msg.poll.votes = {};
                        msg.poll.votes[data.userId] = data.optionIdx;
                        await setDB('messages', chatId, localHistory);
                        if (currentChatId === chatId) renderMessages(chatId);
                    }
                });

                room.onPeerJoin(async peerId => {
                    sendProfile({ id: currentUser.id, name: currentUser.name, pfp: currentUser.pfp }, peerId);
                    if (currentChatId === chatId) updatePeerCount();
                    
                    const history = await getDB('messages', chatId) || [];
                    if (history.length > 0) sendHistory(history, peerId);
                });
                
                room.onPeerLeave(() => {
                    if (currentChatId === chatId) updatePeerCount();
                });

            } catch (e) { console.error("Failed to join room", chatId, e); }
        }

        function updatePeerCount() {
            if (!currentChatId || !activeRooms[currentChatId]) return;
            let countStr = "Connected";
            
            if (typeof activeRooms[currentChatId].room.getPeers === 'function') {
                const count = Object.keys(activeRooms[currentChatId].room.getPeers()).length;
                countStr = `${count} online`;
            }
            
            document.getElementById('status-text').textContent = `${currentChatId} â€¢ ${countStr}`;
            document.getElementById('status-dot').classList.add('connected');
        }

        let lastNotifTime = 0;
        let recentMessages = [];
        let typingTimers = {};
        let currentlyTyping = {};
        
        function handleTyping(chatId, peerId, isTyping) {
            if (!currentlyTyping[chatId]) currentlyTyping[chatId] = new Set();
            
            if (isTyping) {
                currentlyTyping[chatId].add(peerId);
                
                // Auto-clear after 5 seconds if no 'false' is received
                if (typingTimers[`${chatId}_${peerId}`]) clearTimeout(typingTimers[`${chatId}_${peerId}`]);
                typingTimers[`${chatId}_${peerId}`] = setTimeout(() => handleTyping(chatId, peerId, false), 5000);
            } else {
                currentlyTyping[chatId].delete(peerId);
            }
            
            updateTypingUI(chatId);
        }
        
        function updateTypingUI(chatId) {
            if (currentChatId !== chatId) return;
            
            const typingIndicator = document.getElementById('typing-indicator');
            if (!currentlyTyping[chatId] || currentlyTyping[chatId].size === 0) {
                typingIndicator.classList.remove('visible');
                return;
            }
            
            const typists = Array.from(currentlyTyping[chatId]).map(id => profiles[id] ? profiles[id].name.split(' ')[0] : 'Someone');
            
            let text = '';
            if (typists.length === 1) text = `${typists[0]} is typing...`;
            else if (typists.length === 2) text = `${typists[0]}, ${typists[1]} are typing...`;
            else text = 'Multiple people are typing...';
            
            typingIndicator.textContent = text;
            typingIndicator.classList.add('visible');
        }

        async function handleIncomingMessage(chatId, msg, peerId) {
            // Migrate old chat history specifically off localStorage
            if (localStorage.getItem(`messages_history_${chatId}`)) {
                const oldHist = JSON.parse(localStorage.getItem(`messages_history_${chatId}`));
                await setDB('messages', chatId, oldHist);
                localStorage.removeItem(`messages_history_${chatId}`);
            }

            const history = await getDB('messages', chatId) || [];
            if (!history.find(m => m.id === msg.id)) {
                history.push(msg);
                await setDB('messages', chatId, history);
                
                if (currentChatId === chatId) {
                    appendMessageUI(msg, true);
                } else {
                    const now = Date.now();
                    
                    // --- Spam Detection & Cooldown ---
                    // Keep messages from the last 15 seconds
                    recentMessages = recentMessages.filter(m => now - m.timestamp < 15000);
                    
                    const isImage = !!msg.imageBase64;
                    const isShort = msg.text && msg.text.trim().length <= 3;
                    
                    recentMessages.push({ timestamp: now, isImage, isShort });
                    
                    const imageCount = recentMessages.filter(m => m.isImage).length;
                    const shortCount = recentMessages.filter(m => m.isShort).length;
                    const msgCount = recentMessages.length;
                    
                    // Spam Heuristics: > 2 images recently, > 3 short messages, or > 5 messages in general
                    const isSpam = imageCount > 2 || shortCount > 3 || msgCount > 5;
                    
                    // 3-second global notification cooldown
                    const onCooldown = (now - lastNotifTime) < 3000; 

                    if (!isSpam && !onCooldown) {
                        lastNotifTime = now;
                        const sender = profiles[msg.senderId] ? profiles[msg.senderId].name : 'Someone';
                        const chatName = chats.find(c => c.id === chatId)?.name || 'Chat';
                        const contentPreview = msg.text ? msg.text : 'ðŸ“· Image';
                        
                        Gurasuraisu.showNotification(contentPreview, { heading: `${sender} â€¢ ${chatName}`, icon: 'chat' });
                    }
                }
            }
        }

        document.getElementById('poll-btn').addEventListener('click', async () => {
            const question = await Gurasuraisu.showPrompt('Poll question:', 'Poll');
            if (!question) return;
            const optsRaw = await Gurasuraisu.showPrompt('Options (comma separated):', 'Poll');
            if (!optsRaw) return;
            const options = optsRaw.split(',').map(s => s.trim());
            handleSend(null, null, { question, options, votes: {} });
        });

        async function castVote(msgId, optionIdx) {
            if (!currentChatId || !activeRooms[currentChatId]) return;
            
            // Broadcast to peers
            activeRooms[currentChatId].sendVote({ msgId, optionIdx, userId: currentUser.id });
            
            // Update local state
            const localHistory = await getDB('messages', currentChatId) || [];
            const msg = localHistory.find(m => m.id === msgId);
            if (msg && msg.poll) {
                if (!msg.poll.votes) msg.poll.votes = {};
                msg.poll.votes[currentUser.id] = optionIdx;
                await setDB('messages', currentChatId, localHistory);
                renderMessages(currentChatId);
                Gurasuraisu.playSound('select');
            }
        }

        // --- UI Rendering ---
        function renderChatList() {
            chatListContainer.innerHTML = '';
            if (chats.length === 0) {
                chatListContainer.innerHTML = '<div style="font-size: 0.85rem; padding: 10px;">Start a conversation</div>';
                return;
            }
            chats.forEach(chat => {
                const item = document.createElement('div');
                item.className = 'chat-item';
                item.innerHTML = `
                    <div class="chat-icon">${chat.name.charAt(0).toUpperCase()}</div>
                    <div style="flex-grow: 1; gap: 4px;">
                        <div style="font-weight: 600; font-family: 'Open Runde', sans-serif;">${chat.name}</div>
                        <div style="color: var(--secondary-color)">${chat.id}</div>
                    </div>
                `;
                let pressTimer;
                let isLongPress = false;
                item.addEventListener('pointerdown', () => {
                    isLongPress = false;
                    pressTimer = setTimeout(() => {
                        isLongPress = true;
                        promptDeleteChat(chat.id);
                    }, 500);
                });
                
                const cancelPress = () => { if (pressTimer) clearTimeout(pressTimer); };
                item.addEventListener('pointerup', cancelPress);
                item.addEventListener('pointerleave', cancelPress);
                item.addEventListener('pointercancel', cancelPress);
                
                item.addEventListener('click', () => {
                    if (!isLongPress) openChat(chat.id);
                });
                
                chatListContainer.appendChild(item);
            });
        }

        function openChat(chatId) {
            currentChatId = chatId;
            const chat = chats.find(c => c.id === chatId);
            document.getElementById('current-chat-title').textContent = chat ? chat.name : 'Chat';
            document.getElementById('tab-btn-chat').style.display = 'flex';
            
            updatePeerCount();
            
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            document.getElementById('tab-btn-chat').classList.add('active');
            document.getElementById('chat-content').classList.add('active');
            
            renderMessages(chatId);
            updateTypingUI(chatId);
            if (window.innerWidth > 800) messageInput.focus();
        }
        
        async function renderMessages(chatId) {
            chatMessages.innerHTML = '';

            const history = await getDB('messages', chatId) || [];
            
            if (history.length === 0) {
                chatMessages.innerHTML = `<div style="text-align: center; font-size: 0.85rem; margin-top: 20px;" id="empty-state">Start a conversation</div>`;
            } else {
                history.forEach(msg => appendMessageUI(msg, false));
            }
            scrollToBottom();
        }

        function appendMessageUI(msg) {
            const emptyState = document.getElementById('empty-state');
            if (emptyState) emptyState.remove();

            const isMine = msg.senderId === currentUser.id;
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${isMine ? 'mine' : 'theirs'}`;

            let startX = 0, currentX = 0;
            bubble.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                bubble.style.transition = 'none';
            }, { passive: true });
            
            bubble.addEventListener('touchmove', (e) => {
                if (!startX) return;
                currentX = e.touches[0].clientX;
                let diff = currentX - startX;
                if (Math.abs(diff) > 10) bubble.style.transform = `translateX(${diff * 0.4}px)`;
            }, { passive: true });
            
            bubble.addEventListener('touchend', (e) => {
                bubble.style.transition = 'transform 0.3s cubic-bezier(0.2, 1.3, 0.64, 1)';
                bubble.style.transform = '';
                if (startX && currentX) {
                    let diff = currentX - startX;
                    if (diff > 80) setReply(msg);           // Swipe Right
                    else if (diff < -80) addReaction(msg);  // Swipe Left
                }
                startX = 0; currentX = 0;
            });

            if (msg.replyTo) {
                const replyBanner = document.createElement('div');
                replyBanner.className = 'reply-banner';
                replyBanner.textContent = `Replying to ${msg.replyTo.senderName}: ${msg.replyTo.text}`;
                bubble.appendChild(replyBanner);
            }

            if (!isMine) {
                const senderProfile = profiles[msg.senderId] || { name: 'Unknown', pfp: '' };
                const senderRow = document.createElement('div');
                senderRow.className = 'sender-row';
                
                if (senderProfile.pfp) {
                    const pfpEl = document.createElement('div');
                    pfpEl.className = 'sender-pfp';
                    pfpEl.style.backgroundImage = `url(${senderProfile.pfp})`;
                    senderRow.appendChild(pfpEl);
                }
                
                const senderNameEl = document.createElement('div');
                senderNameEl.className = 'message-sender';
                senderNameEl.textContent = senderProfile.name;
                senderRow.appendChild(senderNameEl);
                bubble.appendChild(senderRow);
            }

            if (msg.text) {
                const textEl = document.createElement('div');
                textEl.className = 'message-text';
                textEl.textContent = msg.text;
                bubble.appendChild(textEl);
            }

            if (msg.imageBase64) {
                const imgEl = document.createElement('img');
                imgEl.className = 'message-image';
                imgEl.src = msg.imageBase64;
                imgEl.onload = () => scrollToBottom();
                bubble.appendChild(imgEl);
            }

            if (msg.poll) {
                const pollBox = document.createElement('div');
                pollBox.className = 'poll-container';
                const totalVotes = msg.poll.votes ? Object.keys(msg.poll.votes).length : 0;

                msg.poll.options.forEach((opt, idx) => {
                    const optBtn = document.createElement('div');
                    optBtn.className = 'poll-option';
                    const voteCount = msg.poll.votes ? Object.values(msg.poll.votes).filter(v => v === idx).length : 0;
                    const pct = totalVotes === 0 ? 0 : (voteCount / totalVotes) * 100;

                    optBtn.innerHTML = `<div class="poll-bar" style="width:${pct}%"></div><span>${opt}</span>`;
                    optBtn.onclick = () => castVote(msg.id, idx);
                    pollBox.appendChild(optBtn);
                });

                const stats = document.createElement('div');
                stats.className = 'poll-stats';
                stats.innerHTML = `<span>${msg.poll.question}</span><span>${totalVotes} votes</span>`;
                pollBox.appendChild(stats);
                bubble.appendChild(pollBox);
            }

            const timeEl = document.createElement('div');
            timeEl.className = 'message-time';
            const date = new Date(msg.timestamp);
            timeEl.textContent = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            bubble.appendChild(timeEl);

            if (msg.reactions && Object.keys(msg.reactions).length > 0) {
                const reactContainer = document.createElement('div');
                reactContainer.className = 'reactions-container';
                const emojis = [...new Set(Object.values(msg.reactions))];
                reactContainer.textContent = emojis.join(' ') + (Object.keys(msg.reactions).length > 1 ? ` ${Object.keys(msg.reactions).length}` : '');
                bubble.appendChild(reactContainer);
            }

            chatMessages.appendChild(bubble);
            scrollToBottom();
        }

        function scrollToBottom() {
            setTimeout(() => {
                if (chatMessages && chatMessages.lastElementChild) {
                    // Reliably scrolls the container to the very last message bubble
                    chatMessages.lastElementChild.scrollIntoView({ behavior: 'smooth', block: 'end' });
                } else if (chatMessages) {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }, 100); // 100ms ensures DOM layout is fully calculated first
        }
        
        // --- Actions ---
        let replyingToMsg = null;

        function setReply(msg) {
            replyingToMsg = msg;
            const indicator = document.getElementById('replying-to-indicator');
            const textStr = msg.text || 'Image';
            document.getElementById('replying-to-text').textContent = `Replying to: ${textStr}`;
            indicator.style.display = 'flex';
            if (window.innerWidth > 800) messageInput.focus();
        }
        
        function cancelReply() { // Exposed globally for the HTML inline onclick
            replyingToMsg = null;
            document.getElementById('replying-to-indicator').style.display = 'none';
        }
        window.cancelReply = cancelReply;

        async function addReaction(msg) {
            const emoji = await Gurasuraisu.showPrompt('Enter something to react with:', 'React to Message', 'ðŸ‘');
            if (!emoji) return;
            
            const localHistory = await getDB('messages', currentChatId) || [];
            const dbMsg = localHistory.find(m => m.id === msg.id);
            if (dbMsg) {
                if (!dbMsg.reactions) dbMsg.reactions = {};
                dbMsg.reactions[currentUser.id] = emoji;
                await setDB('messages', currentChatId, localHistory);
                renderMessages(currentChatId);
                
                if (activeRooms[currentChatId] && activeRooms[currentChatId].sendReaction) {
                    activeRooms[currentChatId].sendReaction({
                        messageId: msg.id,
                        senderId: currentUser.id,
                        emoji: emoji
                    });
                }
            }
        }

        async function promptDeleteChat(chatId) {
            const chat = chats.find(c => c.id === chatId);
            if (!chat) return;
            const confirm = await Gurasuraisu.showConfirm(`Leave and delete chat "${chat.name}"?`);
            if (confirm) {
                chats = chats.filter(c => c.id !== chatId);
                await saveChats();
                await setDB('messages', chatId, []);
                
                if (activeRooms[chatId]) {
                    activeRooms[chatId].room.leave();
                    delete activeRooms[chatId];
                }
                
                if (currentChatId === chatId) {
                    currentChatId = null;
                    document.getElementById('tab-btn-chat').style.display = 'none';
                    tabButtons[0].click();
                }
                renderChatList();
            }
        }

        // --- Core Actions ---
        async function handleSend(text, imageBase64 = null, pollData = null) {
            if (!currentChatId || !activeRooms[currentChatId] || (!text && !imageBase64 && !pollData)) return;
            
            let processedImage = imageBase64;
            if (imageBase64) {
                processedImage = await compressImage(imageBase64);
            }

            const msg = {
                id: 'msg_' + generateRandomString(12),
                senderId: currentUser.id,
                text: text,
                imageBase64: processedImage,
                poll: pollData,
                timestamp: Date.now(),
                replyTo: replyingToMsg ? {
                    id: replyingToMsg.id,
                    text: replyingToMsg.text || 'Image',
                    senderName: profiles[replyingToMsg.senderId]?.name || 'Someone'
                } : null
            };

            cancelReply();

            const history = await getDB('messages', currentChatId) || [];
            history.push(msg);
            await setDB('messages', currentChatId, history);

            appendMessageUI(msg, true);
            Gurasuraisu.playSound('check');
            activeRooms[currentChatId].sendChat(msg);
            
            if (text) messageInput.value = '';
            if (window.innerWidth > 800) messageInput.focus();
        }

        let localTypingTimer = null;
        function broadcastTyping(isTyping) {
            if (currentChatId && activeRooms[currentChatId] && activeRooms[currentChatId].sendTyping) {
                activeRooms[currentChatId].sendTyping(isTyping);
            }
        }

        sendBtn.addEventListener('click', () => {
            broadcastTyping(false);
            handleSend(messageInput.value.trim());
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                broadcastTyping(false);
                if (localTypingTimer) clearTimeout(localTypingTimer);
                handleSend(messageInput.value.trim());
            }
        });

        messageInput.addEventListener('input', () => {
            if (messageInput.value.trim().length > 0) {
                broadcastTyping(true);
                if (localTypingTimer) clearTimeout(localTypingTimer);
                localTypingTimer = setTimeout(() => broadcastTyping(false), 3000);
            } else {
                broadcastTyping(false);
            }
        });
        
        messageInput.addEventListener('blur', () => broadcastTyping(false));

        attachBtn.addEventListener('click', async () => {
            try {
                const files = await Gurasuraisu.requestFile({ accept: 'image/*', multiple: false });
                if (files && files.length > 0) {
                    const reader = new FileReader();
                    reader.onload = (e) => handleSend('', e.target.result);
                    reader.readAsDataURL(files[0]);
                }
            } catch(e) { console.error(e); }
        });

        // Profile Tab Sync
        function updateProfileUI() {
            if (!currentUser) return;
            document.getElementById('settings-name-input').value = currentUser.name;
            document.getElementById('settings-pfp-preview').style.backgroundImage = `url(${currentUser.pfp})`;
            document.getElementById('my-internal-id').textContent = currentUser.id;
        }

        document.getElementById('settings-pfp-preview').addEventListener('click', async () => {
            const files = await Gurasuraisu.requestFile({ accept: 'image/*', multiple: false });
            if (files && files.length > 0) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('settings-pfp-preview').style.backgroundImage = `url(${e.target.result})`;
                    currentUser.pfp = e.target.result;
                };
                reader.readAsDataURL(files[0]);
            }
        });

        document.getElementById('save-profile-btn').addEventListener('click', async () => {
            currentUser.name = document.getElementById('settings-name-input').value.trim() || currentUser.name;
            await setDB('state', 'currentUser', currentUser);
            profiles[currentUser.id] = { name: currentUser.name, pfp: currentUser.pfp };
            await saveProfiles();
            Gurasuraisu.showPopup('Profile updated');
            Object.values(activeRooms).forEach(r => r.sendProfile({ id: currentUser.id, name: currentUser.name, pfp: currentUser.pfp }));
        });
        
        async function handleJoinOrCreate() {
            const input = document.getElementById('join-code-input').value.trim();
            if (!input) return;

            const existing = chats.find(c => c.id === input || c.name.toLowerCase() === input.toLowerCase());
            if (existing) { openChat(existing.id); document.getElementById('join-code-input').value = ''; return; }

            const isRoomId = /^[A-Za-z0-9]{8}$/.test(input);
            if (isRoomId) {
                const pass = await Gurasuraisu.showPrompt('Enter chat password (if any) or leave blank:', 'Password');
                chats.push({ id: input, name: `Chat ${input}`, password: pass });
                await saveChats();
                joinTrysteroRoom(input);
                renderChatList(); openChat(input);
            } else {
                const pass = await Gurasuraisu.showPrompt('Set a password for this new chat (optional):', 'Password');
                const newId = generateRandomString(8);
                chats.push({ id: newId, name: input, password: pass });
                await saveChats();
                joinTrysteroRoom(newId);
                renderChatList(); openChat(newId);
                Gurasuraisu.showPopup(`Created chat ${newId}`);
            }
            document.getElementById('join-code-input').value = '';
        }

        document.getElementById('join-create-chat-btn').addEventListener('click', handleJoinOrCreate);
        document.getElementById('join-code-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleJoinOrCreate();
        });

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
